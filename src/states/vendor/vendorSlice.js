/**
 *----------------------------@mit----------------------------
 * This is the vendor slice that will responsible for
 * fetching the vendors from the server and 
 * managing their state.
 * -----------------------------------------------------------
 */

import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { fetchVendors, addVendor, updateVendor, deleteVendor } from './apis';

/**
 * Initial vendorSlice State 
 */
const initialState = {
    value: [],
    selected: null,
    status: 'idle',
    error: null,
};

/**
 * Function to handle the async request to fetch the vendors from the server
 */
export const fetchVendorsAsync = createAsyncThunk(
    'vendor/fetchVendors',
    async () => {
        const response = await fetchVendors();
        return response.data;
    }
);

/**
 * Function to handle the async request to add a vendor to the server
 */
export const addVendorAsync = createAsyncThunk(
    'vendor/addVendor',
    async (vendor) => {
        const response = await addVendor(vendor);
        return response.data;
    }
);


/**
 * Function to handle the async request to update a vendor to the server
 */
export const updateVendorAsync = createAsyncThunk(
    'vendor/updateVendor',
    async (vendor) => {
        const response = await updateVendor(vendor);
        return response.data;
    }
);


/**
 * Function to handle the async request to delete a vendor from the server
 */
export const deleteVendorAsync = createAsyncThunk(
    'vendor/deleteVendor',
    async (vendor) => {
        const response = await deleteVendor(vendor);
        return response.data;
    }
);


/**
 * Creating vendorSice to handle the vendors state
 */
const vendorSlice = createSlice({
    name: 'vendor',
    initialState,
    reducers: {
        select: (state, action) => {
            state.selected = action.payload.vendor;
        },
    },
    // lets handle actions generated by createAsyncThunk or in other slices.
    // with the extra reducers
    extraReducers: (builder) => {
        builder
            .addCase(fetchVendorsAsync.pending, (state) => {
                state.status = 'fetching';
            })
            .addCase(fetchVendorsAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                state.value = action.payload;
            })
            .addCase(fetchVendorsAsync.rejected, (state, action) => {
                state.status = 'idle';
                state.error = action.error;
            })
            .addCase(addVendorAsync.pending, (state) => {
                state.status = 'adding';
            })
            .addCase(addVendorAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                state.value.push(action.payload);
            })
            .addCase(addVendorAsync.rejected, (state, action) => {
                state.status = 'idle';
                state.error = action.error;
            })
            .addCase(updateVendorAsync.pending, (state) => {
                state.status = 'updating';
            })
            .addCase(updateVendorAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                const index = state.value.findIndex(vendor => vendor.id === action.payload.id);
                state.value[index] = action.payload;
            })
            .addCase(updateVendorAsync.rejected, (state, action) => {
                state.status = 'idle';
                state.error = action.error;
            })
            .addCase(deleteVendorAsync.pending, (state) => {
                state.status = 'deleting';
            })
            .addCase(deleteVendorAsync.fulfilled, (state, action) => {
                state.status = 'idle';
                const index = state.value.findIndex(vendor => vendor.id === action.payload.id);
                state.value.splice(index, 1);
            })
            .addCase(deleteVendorAsync.rejected, (state, action) => {
                state.status = 'idle';
                state.error = action.error;
            });

    },
});


/**
 * Exporting the actions from the vendorSlice
 */
export const { select } = vendorSlice.actions;

/**
 * This will be used to select the value from the state in the component using the useSelector hook
 * @param {*} state 
 * @returns 
 */
export const selectVendors = (state) => state.vendor.value;
export const selectSelectedVendor = (state) => state.vendor.selected;
export const selectVendorStatus = (state) => state.vendor.status;
export const selectVendorError = (state) => state.vendor.error;

/**
 * FInally Exporting the reducer from the vendorSlice
 */
export default vendorSlice.reducer;
